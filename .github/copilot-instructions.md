# Copilot Code Generation Instructions

## Rust Code Guidelines

When generating Rust code for DataFusion, please follow these guidelines:

### Idiomatic Rust

- Use snake_case for variables, functions, and modules
- Use CamelCase for types, traits, and enum variants
- Prefer pattern matching and destructuring over explicit indexing
- Use iterators rather than explicit loops where appropriate
- Utilize the type system with enums and strong typing rather than raw values
- Use `Option<T>` instead of nullable types or sentinel values
- Use `Result<T, E>` for fallible operations instead of returning special error codes
- Implement appropriate traits (`Display`, `Debug`, `Clone`, etc.) when needed

### Clippy Compliance

- Avoid redundant clones and unnecessary allocations
- Avoid unnecessary `unwrap()` calls, prefer error handling or `?` operator
- Use `#[derive]` for standard traits where possible
- Follow naming conventions for lifetimes (usually single lowercase letters)
- Avoid large array allocations on the stack
- Use specific integer types (`usize`, `u32`, etc.) instead of defaulting to `i32`
- Avoid unnecessary `&mut` references when immutable references will suffice
- Avoid wildcard imports (`use crate::*`)

### Error Handling

- Return `Result<T, Error>` for functions that can fail
- Use the `?` operator for error propagation
- Implement custom errors using the `thiserror` crate when appropriate
- Add context to errors when propagating them

### Performance Considerations

- Consider using `&str` instead of `String` for function parameters when possible
- Use `Arc` for shared ownership when needed
- Utilize zero-copy techniques where appropriate
- Consider memory layout and cache efficiency for critical paths

### Code Organization

- Keep functions concise and focused on a single task
- Aim for functions under 40-50 lines of code
- Break long or complex operations into smaller, well-named helper functions
- Before creating new utility functions, check if existing helper functions in the codebase can be reused or extended
- Consider adding parameters to existing functions rather than creating similar parallel implementations
- Don't overengineer; avoid creating abstractions that are not needed
- Look for similar patterns in the codebase and follow established conventions
- Reuse traits, error types, and utility functions from the common modules when applicable
- Group related functions into modules or impl blocks
- Prefer composition over inheritance through traits and generic parameters
- Extract complex logic into separate, testable functions
- Use private implementation details with public interfaces when appropriate
- Consider using the newtype pattern to provide type safety for domain-specific values

### Documentation

- Add doc comments (`///`) for public API items
- Include examples in documentation where helpful
- Document panicking conditions
- Document performance considerations for critical functions

### Code Comments

- Use clear comments to explain complex algorithms or business logic
- Comment on "why" rather than "what" when the code isn't self-explanatory
- Keep comments up-to-date with code changes

==> Generated by Copilot
